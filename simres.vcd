$date
	Fri Jun 28 21:04:39 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 32 4 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 5 memtoreg $end
$var wire 1 6 lui $end
$var wire 1 7 dojump $end
$var wire 1 8 dobranch $end
$var wire 5 9 destreg [4:0] $end
$var wire 1 : alusrcbimm $end
$var wire 32 ; aluout [31:0] $end
$var wire 3 < alucontrol [2:0] $end
$var wire 1 = OrImm $end
$scope module decoder $end
$var wire 32 > instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 ? op [5:0] $end
$var wire 6 @ funct [5:0] $end
$var reg 1 = OrImm $end
$var reg 3 A alucontrol [2:0] $end
$var reg 1 : alusrcbimm $end
$var reg 5 B destreg [4:0] $end
$var reg 1 8 dobranch $end
$var reg 1 7 dojump $end
$var reg 1 6 lui $end
$var reg 1 5 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 3 regwrite $end
$upscope $end
$scope module dp $end
$var wire 1 = OrImm $end
$var wire 3 C alucontrol [2:0] $end
$var wire 1 : alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 D destreg [4:0] $end
$var wire 1 8 dobranch $end
$var wire 32 E instr [31:0] $end
$var wire 1 7 jump $end
$var wire 1 6 lui $end
$var wire 1 5 memtoreg $end
$var wire 32 F readdata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 1 " reset $end
$var wire 32 G writedata [31:0] $end
$var wire 1 1 zero $end
$var wire 32 H srcbimm [31:0] $end
$var wire 32 I srcb [31:0] $end
$var wire 32 J srca [31:0] $end
$var wire 32 K signimm [31:0] $end
$var wire 32 L result [31:0] $end
$var wire 32 M pc [31:0] $end
$var wire 32 N aluout [31:0] $end
$scope module alu $end
$var wire 3 O alucontrol [2:0] $end
$var wire 32 P b [31:0] $end
$var wire 32 Q a [31:0] $end
$var reg 32 R hi [31:0] $end
$var reg 32 S lo [31:0] $end
$var reg 32 T result [31:0] $end
$var reg 67 U temp [66:0] $end
$var reg 1 1 zero $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 V ra1 [4:0] $end
$var wire 5 W ra2 [4:0] $end
$var wire 5 X wa3 [4:0] $end
$var wire 32 Y wd3 [31:0] $end
$var wire 1 3 we3 $end
$var wire 32 Z rd2 [31:0] $end
$var wire 32 [ rd1 [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ! clk $end
$var wire 1 8 dobranch $end
$var wire 1 7 dojump $end
$var wire 26 \ jumptarget [25:0] $end
$var wire 32 ] progcounter [31:0] $end
$var wire 1 " reset $end
$var wire 32 ^ nextpc [31:0] $end
$var wire 32 _ incpc [31:0] $end
$var wire 32 ` branchpc [31:0] $end
$var wire 32 a branchoffset [31:0] $end
$var reg 32 b pc [31:0] $end
$scope module pcbranch $end
$var wire 32 c b [31:0] $end
$var wire 1 d cin $end
$var wire 32 e y [31:0] $end
$var wire 1 f cout $end
$var wire 32 g a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 h a [31:0] $end
$var wire 32 i b [31:0] $end
$var wire 1 j cin $end
$var wire 32 k y [31:0] $end
$var wire 1 l cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 1 = OrImm $end
$var wire 16 m a [15:0] $end
$var wire 1 6 lui $end
$var wire 32 n y [31:0] $end
$var reg 32 o out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1010101000000000000000000 o
b1010101000000000000000000 n
b101010100 m
0l
b10000000000000000000100 k
0j
b100 i
b10000000000000000000000 h
b10000000000000000000100 g
0f
b101100100000000000000000100 e
0d
b101010100000000000000000000 c
b10000000000000000000000 b
b1010101000000000000000000 a
b101100100000000000000000100 `
b10000000000000000000100 _
b10000000000000000000100 ^
b10000000000000000000000 ]
b10000000101010100 \
b0 [
b11001010111111101011101010111110 Z
b1010101000000000000000000 Y
b1 X
b1 W
b0 V
bx U
b1010101000000000000000000 T
bx S
bx R
b0 Q
b1010101000000000000000000 P
b1 O
b1010101000000000000000000 N
b10000000000000000000000 M
b1010101000000000000000000 L
b1010101000000000000000000 K
b0 J
b11001010111111101011101010111110 I
b1010101000000000000000000 H
b11001010111111101011101010111110 G
bx F
b111100000000010000000101010100 E
b1 D
b1 C
b1 B
b1 A
b10100 @
b1111 ?
b111100000000010000000101010100 >
0=
b1 <
b1010101000000000000000000 ;
1:
b1 9
08
07
16
05
b10000000000000000000000 4
13
b11001010111111101011101010111110 2
01
bx 0
b111100000000010000000101010100 /
b111100000000010000000101010100 .
b0 -
b11001010111111101011101010111110 ,
bx +
b0 *
b1010101000000000000000000 )
0(
b111100000000010000000101010100 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
b1010101000000000000000000 $
b1010101000000000000000000 ,
b1010101000000000000000000 2
b1010101000000000000000000 G
b1010101000000000000000000 I
b1010101000000000000000000 Z
1!
#5
0"
#6
0!
#8
b1010101001010100101010101 L
b1010101001010100101010101 Y
b10101 *
b1010101001010100101010101 )
b1010101001010100101010101 ;
b1010101001010100101010101 N
b1010101001010100101010101 T
b101010010101010100 c
b1010100101010101 H
b1010100101010101 P
b10000000000000000001000 ^
b1010100101010101 K
b1010100101010101 a
b1010100101010101 n
b1010100101010101 o
b1010101000000000000000000 J
b1010101000000000000000000 Q
b1010101000000000000000000 [
b10000101010010101011100 `
b10000101010010101011100 e
1=
06
b1101 ?
b10101 @
b1000011010100101010101 \
b1010100101010101 m
b1 V
b10000000000000000001000 _
b10000000000000000001000 g
b10000000000000000001000 k
b110100001000011010100101010101 '
b110100001000011010100101010101 .
b110100001000011010100101010101 /
b110100001000011010100101010101 >
b110100001000011010100101010101 E
b1 -
b10000000000000000000100 &
b10000000000000000000100 4
b10000000000000000000100 M
b10000000000000000000100 ]
b10000000000000000000100 b
b10000000000000000000100 h
1!
#10
0!
#12
b10000010000100 c
b1010101001010100101010101 L
b1010101001010100101010101 Y
b10101 *
b10000000000000000001100 ^
b1010101001010100101010101 H
b1010101001010100101010101 P
b100000100001 K
b100000100001 a
b100000100001 n
b100000100001 o
b1010101001010100101010101 )
b1010101001010100101010101 ;
b1010101001010100101010101 N
b1010101001010100101010101 T
b10000000010000010010000 `
b10000000010000010010000 e
b10 <
b10 A
b10 C
b10 O
0=
0:
b0 ?
b100001 @
b10000100000100001 \
b100000100001 m
b0 V
b0 J
b0 Q
b0 [
b1010101001010100101010101 $
b1010101001010100101010101 ,
b1010101001010100101010101 2
b1010101001010100101010101 G
b1010101001010100101010101 I
b1010101001010100101010101 Z
b10000000000000000001100 _
b10000000000000000001100 g
b10000000000000000001100 k
b10000100000100001 '
b10000100000100001 .
b10000100000100001 /
b10000100000100001 >
b10000100000100001 E
b10 -
b10000000000000000001000 &
b10000000000000000001000 4
b10000000000000000001000 M
b10000000000000000001000 ]
b10000000000000000001000 b
b10000000000000000001000 h
1!
#14
0!
#16
b1010101000000000000000000 L
b1010101000000000000000000 Y
b0 *
b101010100000000000000000000 c
b10000000000000000010000 ^
b1010101000000000000000000 )
b1010101000000000000000000 ;
b1010101000000000000000000 N
b1010101000000000000000000 T
b1010101000000000000000000 H
b1010101000000000000000000 P
b1010101000000000000000000 K
b1010101000000000000000000 a
b1010101000000000000000000 n
b1010101000000000000000000 o
b101100100000000000000010000 `
b101100100000000000000010000 e
b1 <
b1 A
b1 C
b1 O
1:
16
b1111 ?
b10100 @
b10000000101010100 \
b101010100 m
b10000000000000000010000 _
b10000000000000000010000 g
b10000000000000000010000 k
b111100000000010000000101010100 '
b111100000000010000000101010100 .
b111100000000010000000101010100 /
b111100000000010000000101010100 >
b111100000000010000000101010100 E
b11 -
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 M
b10000000000000000001100 ]
b10000000000000000001100 b
b10000000000000000001100 h
1!
#18
0!
#20
b1010101001010100101010101 L
b1010101001010100101010101 Y
b10101 *
b1010101001010100101010101 )
b1010101001010100101010101 ;
b1010101001010100101010101 N
b1010101001010100101010101 T
b101010010101010100 c
b1010100101010101 H
b1010100101010101 P
b10000000000000000010100 ^
b1010100101010101 K
b1010100101010101 a
b1010100101010101 n
b1010100101010101 o
b1010101000000000000000000 J
b1010101000000000000000000 Q
b1010101000000000000000000 [
b10000101010010101101000 `
b10000101010010101101000 e
1=
06
b1101 ?
b10101 @
b1000011010100101010101 \
b1010100101010101 m
b1 V
b1010101000000000000000000 $
b1010101000000000000000000 ,
b1010101000000000000000000 2
b1010101000000000000000000 G
b1010101000000000000000000 I
b1010101000000000000000000 Z
b10000000000000000010100 _
b10000000000000000010100 g
b10000000000000000010100 k
b110100001000011010100101010101 '
b110100001000011010100101010101 .
b110100001000011010100101010101 /
b110100001000011010100101010101 >
b110100001000011010100101010101 E
b100 -
b10000000000000000010000 &
b10000000000000000010000 4
b10000000000000000010000 M
b10000000000000000010000 ]
b10000000000000000010000 b
b10000000000000000010000 h
1!
#21
b1 #

$date
	Sat Jun 29 16:53:26 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 32 4 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 5 memtoreg $end
$var wire 1 6 lui $end
$var wire 1 7 dojump $end
$var wire 1 8 dojal $end
$var wire 1 9 dobranch $end
$var wire 5 : destreg [4:0] $end
$var wire 1 ; alusrcbimm $end
$var wire 32 < aluout [31:0] $end
$var wire 3 = alucontrol [2:0] $end
$var wire 1 > OrImm $end
$scope module decoder $end
$var wire 32 ? instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 @ op [5:0] $end
$var wire 6 A funct [5:0] $end
$var reg 1 > OrImm $end
$var reg 3 B alucontrol [2:0] $end
$var reg 1 ; alusrcbimm $end
$var reg 5 C destreg [4:0] $end
$var reg 1 9 dobranch $end
$var reg 1 8 dojal $end
$var reg 1 7 dojump $end
$var reg 1 6 lui $end
$var reg 1 5 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 3 regwrite $end
$upscope $end
$scope module dp $end
$var wire 1 > OrImm $end
$var wire 3 D alucontrol [2:0] $end
$var wire 1 ; alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 E destreg [4:0] $end
$var wire 1 9 dobranch $end
$var wire 1 8 dojal $end
$var wire 32 F instr [31:0] $end
$var wire 1 7 jump $end
$var wire 1 6 lui $end
$var wire 1 5 memtoreg $end
$var wire 32 G readdata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 1 " reset $end
$var wire 32 H writedata [31:0] $end
$var wire 1 1 zero $end
$var wire 32 I srcbimm [31:0] $end
$var wire 32 J srcb [31:0] $end
$var wire 32 K srca [31:0] $end
$var wire 32 L signimm [31:0] $end
$var wire 32 M result [31:0] $end
$var wire 32 N pcresult [31:0] $end
$var wire 32 O pc [31:0] $end
$var wire 32 P aluout [31:0] $end
$scope module alu $end
$var wire 3 Q alucontrol [2:0] $end
$var wire 32 R b [31:0] $end
$var wire 32 S a [31:0] $end
$var reg 32 T hi [31:0] $end
$var reg 32 U lo [31:0] $end
$var reg 32 V result [31:0] $end
$var reg 65 W temp [64:0] $end
$var reg 1 1 zero $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 X ra1 [4:0] $end
$var wire 5 Y ra2 [4:0] $end
$var wire 5 Z wa3 [4:0] $end
$var wire 32 [ wd3 [31:0] $end
$var wire 1 3 we3 $end
$var wire 32 \ rd2 [31:0] $end
$var wire 32 ] rd1 [31:0] $end
$var wire 32 ^ newpc [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ! clk $end
$var wire 1 9 dobranch $end
$var wire 1 8 dojal $end
$var wire 1 7 dojump $end
$var wire 26 _ jumptarget [25:0] $end
$var wire 32 ` progcounter [31:0] $end
$var wire 1 " reset $end
$var wire 32 a pcresult [31:0] $end
$var wire 32 b nextpc [31:0] $end
$var wire 32 c incpc [31:0] $end
$var wire 32 d branchpc [31:0] $end
$var wire 32 e branchoffset [31:0] $end
$var reg 32 f pc [31:0] $end
$scope module pcbranch $end
$var wire 32 g b [31:0] $end
$var wire 1 h cin $end
$var wire 32 i y [31:0] $end
$var wire 1 j cout $end
$var wire 32 k a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 l a [31:0] $end
$var wire 32 m b [31:0] $end
$var wire 1 n cin $end
$var wire 32 o y [31:0] $end
$var wire 1 p cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 1 > OrImm $end
$var wire 16 q a [15:0] $end
$var wire 1 6 lui $end
$var wire 32 r y [31:0] $end
$var reg 32 s out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11 s
b11 r
b11 q
0p
b10000000000000000000100 o
0n
b100 m
b10000000000000000000000 l
b10000000000000000000100 k
0j
b10000000000000000010000 i
0h
b1100 g
b10000000000000000000000 f
b11 e
b10000000000000000010000 d
b10000000000000000000100 c
b10000000000000000001100 b
b10000000000000000000100 a
b10000000000000000000000 `
b100000000000000000011 _
b10000000000000000000100 ^
b0 ]
b11001010111111101011101010111110 \
bx [
b11111 Z
b10000 Y
b0 X
bx W
bx V
bx U
bx T
b0 S
b11001010111111101011101010111110 R
bx Q
bx P
b10000000000000000000000 O
b10000000000000000000100 N
bx M
b11 L
b0 K
b11001010111111101011101010111110 J
b11001010111111101011101010111110 I
b11001010111111101011101010111110 H
bx G
b1100000100000000000000000011 F
b11111 E
bx D
b11111 C
bx B
b11 A
b11 @
b1100000100000000000000000011 ?
0>
bx =
bx <
0;
b11111 :
09
18
17
06
05
b10000000000000000000000 4
13
b11001010111111101011101010111110 2
01
bx 0
b1100000100000000000000000011 /
b1100000100000000000000000011 .
b0 -
b11001010111111101011101010111110 ,
bx +
bx *
bx )
0(
b1100000100000000000000000011 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
1!
#5
0"
#6
0!
#8
b1111011 M
b1111011 [
b11110 *
b111101100 g
b1111011 )
b1111011 <
b1111011 P
b1111011 V
b1111011 I
b1111011 R
b10000000000000000010000 b
b1111011 L
b1111011 e
b1111011 r
b1111011 s
b10000000000000111111100 d
b10000000000000111111100 i
b0 N
b0 ^
b0 a
b10 =
b10 B
b10 D
b10 Q
07
1;
b101 :
b101 C
b101 E
b101 Z
08
b1001 @
b111011 A
b1010000000001111011 _
b1111011 q
b101 Y
b10000000000000000010000 c
b10000000000000000010000 k
b10000000000000000010000 o
b100100000001010000000001111011 '
b100100000001010000000001111011 .
b100100000001010000000001111011 /
b100100000001010000000001111011 ?
b100100000001010000000001111011 F
b11 -
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 O
b10000000000000000001100 `
b10000000000000000001100 f
b10000000000000000001100 l
1!
#10
0!
#12
xj
bx00 g
bx b
bx M
bx [
bx I
bx R
bx L
bx e
bx r
bx s
bx K
bx S
bx ]
bx d
bx i
bx =
bx B
bx D
bx Q
x6
x>
x7
x5
x(
x9
x;
bx :
bx C
bx E
bx Z
x3
bx @
bx A
bx _
bx q
bx X
bx Y
bx $
bx ,
bx 2
bx H
bx J
bx \
b10000000000000000010100 c
b10000000000000000010100 k
b10000000000000000010100 o
bx '
bx .
bx /
bx ?
bx F
b100 -
b10000000000000000010000 &
b10000000000000000010000 4
b10000000000000000010000 O
b10000000000000000010000 `
b10000000000000000010000 f
b10000000000000000010000 l
1!
#14
0!
#16
bx c
bx k
bx o
xp
bx -
bx &
bx 4
bx O
bx `
bx f
bx l
1!
#18
0!
#20
1!
#22
0!
#24
1!
#25
b101 #

$date
	Thu Jun 27 14:13:35 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 32 4 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 5 memtoreg $end
$var wire 1 6 dojump $end
$var wire 1 7 dobranch $end
$var wire 5 8 destreg [4:0] $end
$var wire 1 9 alusrcbimm $end
$var wire 32 : aluout [31:0] $end
$var wire 3 ; alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 < instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 = op [5:0] $end
$var wire 6 > funct [5:0] $end
$var reg 3 ? alucontrol [2:0] $end
$var reg 1 9 alusrcbimm $end
$var reg 5 @ destreg [4:0] $end
$var reg 1 7 dobranch $end
$var reg 1 6 dojump $end
$var reg 1 5 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 3 regwrite $end
$upscope $end
$scope module dp $end
$var wire 3 A alucontrol [2:0] $end
$var wire 1 9 alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 B destreg [4:0] $end
$var wire 1 7 dobranch $end
$var wire 32 C instr [31:0] $end
$var wire 1 6 jump $end
$var wire 1 5 memtoreg $end
$var wire 32 D readdata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 1 " reset $end
$var wire 32 E writedata [31:0] $end
$var wire 1 1 zero $end
$var wire 32 F srcbimm [31:0] $end
$var wire 32 G srcb [31:0] $end
$var wire 32 H srca [31:0] $end
$var wire 32 I signimm [31:0] $end
$var wire 32 J result [31:0] $end
$var wire 32 K pc [31:0] $end
$var wire 32 L aluout [31:0] $end
$scope module alu $end
$var wire 3 M alucontrol [2:0] $end
$var wire 32 N b [31:0] $end
$var wire 32 O a [31:0] $end
$var reg 32 P hi [31:0] $end
$var reg 32 Q lo [31:0] $end
$var reg 32 R result [31:0] $end
$var reg 62 S temp [61:0] $end
$var reg 1 1 zero $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 T ra1 [4:0] $end
$var wire 5 U ra2 [4:0] $end
$var wire 5 V wa3 [4:0] $end
$var wire 32 W wd3 [31:0] $end
$var wire 1 3 we3 $end
$var wire 32 X rd2 [31:0] $end
$var wire 32 Y rd1 [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ! clk $end
$var wire 1 7 dobranch $end
$var wire 1 6 dojump $end
$var wire 26 Z jumptarget [25:0] $end
$var wire 32 [ progcounter [31:0] $end
$var wire 1 " reset $end
$var wire 32 \ nextpc [31:0] $end
$var wire 32 ] incpc [31:0] $end
$var wire 32 ^ branchpc [31:0] $end
$var wire 32 _ branchoffset [31:0] $end
$var reg 32 ` pc [31:0] $end
$scope module pcbranch $end
$var wire 32 a b [31:0] $end
$var wire 1 b cin $end
$var wire 32 c y [31:0] $end
$var wire 1 d cout $end
$var wire 32 e a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 f a [31:0] $end
$var wire 32 g b [31:0] $end
$var wire 1 h cin $end
$var wire 32 i y [31:0] $end
$var wire 1 j cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 k a [15:0] $end
$var wire 32 l y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1001000110100 l
b1001000110100 k
0j
b10000000000000000000100 i
0h
b100 g
b10000000000000000000000 f
b10000000000000000000100 e
0d
b10000000100100011010100 c
0b
b100100011010000 a
b10000000000000000000000 `
b1001000110100 _
b10000000100100011010100 ^
b10000000000000000000100 ]
b10000000000000000000100 \
b10000000000000000000000 [
b10001001000110100 Z
b0 Y
b11001010111111101011101010111110 X
bx W
b1 V
b1 U
b0 T
bx S
bx R
bx Q
bx P
b0 O
b1001000110100 N
bx M
bx L
b10000000000000000000000 K
bx J
b1001000110100 I
b0 H
b11001010111111101011101010111110 G
b1001000110100 F
b11001010111111101011101010111110 E
bx D
b111100000000010001001000110100 C
b1 B
bx A
b1 @
bx ?
b110100 >
b1111 =
b111100000000010001001000110100 <
bx ;
bx :
19
b1 8
07
06
05
b10000000000000000000000 4
13
b11001010111111101011101010111110 2
01
bx 0
b111100000000010001001000110100 /
b111100000000010001001000110100 .
b0 -
b11001010111111101011101010111110 ,
bx +
bx *
bx )
1(
b111100000000010001001000110100 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
bx $
bx ,
bx 2
bx E
bx G
bx X
1!
#5
0"
#6
0!
#8
b10000000000000000001000 \
bx H
bx O
bx Y
b10000000100100011011000 ^
b10000000100100011011000 c
15
b1101 =
b1000010001001000110100 Z
b1 T
b10000000000000000001000 ]
b10000000000000000001000 e
b10000000000000000001000 i
b110100001000010001001000110100 '
b110100001000010001001000110100 .
b110100001000010001001000110100 /
b110100001000010001001000110100 <
b110100001000010001001000110100 C
b1 -
b10000000000000000000100 &
b10000000000000000000100 4
b10000000000000000000100 K
b10000000000000000000100 [
b10000000000000000000100 `
b10000000000000000000100 f
1!
#10
0!
#12
b1 *
b10000000000000000001100 \
b100 )
b100 :
b100 L
b100 R
b10000 a
b100 F
b100 N
b0 H
b0 O
b0 Y
b10000000000000000011100 ^
b10000000000000000011100 c
b10 ;
b10 ?
b10 A
b10 M
03
b101011 =
b100 >
b10000000000000100 Z
b100 I
b100 _
b100 l
b100 k
b0 T
b10000000000000000001100 ]
b10000000000000000001100 e
b10000000000000000001100 i
b10101100000000010000000000000100 '
b10101100000000010000000000000100 .
b10101100000000010000000000000100 /
b10101100000000010000000000000100 <
b10101100000000010000000000000100 C
b10 -
b10000000000000000001000 &
b10000000000000000001000 4
b10000000000000000001000 K
b10000000000000000001000 [
b10000000000000000001000 `
b10000000000000000001000 f
1!
#14
0!
#16
xd
bx \
bx00 a
bx F
bx N
bx H
bx O
bx Y
bx ^
bx c
bx ;
bx ?
bx A
bx M
x6
x5
x(
x7
x9
bx 8
bx @
bx B
bx V
x3
bx =
bx >
bx Z
bx I
bx _
bx l
bx k
bx T
bx U
b10000000000000000010000 ]
b10000000000000000010000 e
b10000000000000000010000 i
bx '
bx .
bx /
bx <
bx C
b11 -
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 K
b10000000000000000001100 [
b10000000000000000001100 `
b10000000000000000001100 f
1!
#18
0!
#20
bx ]
bx e
bx i
xj
bx -
bx &
bx 4
bx K
bx [
bx `
bx f
1!
#21
b1 #
